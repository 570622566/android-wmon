package com.gnychis.awmon.DeviceAbstraction;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

import android.content.Context;
import android.os.Parcel;
import android.os.Parcelable;

import com.gnychis.awmon.Core.UserSettings;
import com.gnychis.awmon.HardwareHandlers.Wifi;


/**
 * A device is a physical thing.  Like a laptop, an access point, etc.  It can have multiple radios attached
 * which we save and represent as interfaces.
 * 
 * @author George Nychis (gnychis)
 */
public class Device implements Parcelable {
	
	public enum Mobility {		// Possible types of radios that we support
		UNKNOWN,
		MOBILE,
		FIXED,
	}

	List<Interface> _interfaces;	// Keep track of each radio detected
	private String _userName;		// A name for the device, could be user generated?
	Mobility _mobile;
	private int _deviceKey;			// A unique key generated by a random number for this device
	boolean _internal;				// Whether the device is internal (belongs to user) or not.
		
	public Device() {
		_interfaces = new ArrayList<Interface>();
		_userName = null;
		_mobile=Device.Mobility.UNKNOWN;
		_internal=false;
		_deviceKey = generateKey();
	}
	
	public Device(List<Interface> interfaces) {
		_interfaces = interfaces;
		_userName = null;
		_mobile=Device.Mobility.UNKNOWN;
		_internal=false;
		_deviceKey = generateKey();
	}
	
	/** Sets the mobility state of the device
	 * @param m the state to set the mobility to
	 */
	public void setMobility(Mobility m) {
		_mobile=m;
	}
	
	/**
	 * Returns the state of the device's mobility
	 * @return the mobile state of the device
	 */
	public Mobility getMobility() {
		return _mobile;
	}
	
	/** Sets whether or not the device is internal (the user's) or not.
	 * @param isInternal true if internal, false otherwise.
	 */
	public void setInternal(boolean isInternal) {
		_internal=isInternal;
	}
	
	/** Gets the state of whether the device is internal or not.
	 * @return true if the device is internal, false otherwise
	 */
	public boolean getInternal() {
		return _internal;
	}
	
	/** The purpose of this function is to retrieve some additional or useful information about the device
	 * that might help the user recognize or separate it from other devices.  We need a context to access settings.
	 * @return additional information as a string.
	 */
	public String getAdditional(Context c) {
		UserSettings _settings = new UserSettings(c);
		
		// If this device has an interface with the same MAC address as the phone's (the thing the user is holding)
		// MAC, we say: "Hey, this is the device in your hand"
		if(hasInterfaceWithMAC(_settings.getPhoneWifiMAC()))
			return "The phone you're using right now!";
		
		// To check if this device is the home access point, you could check for Wifi interfaces, but an easy and guaranteed
		// one is to check whether it has the Gateway IP address
		if(hasGatewayInterface())
			return "Your access point (\"" + _settings.getHomeSSID() + "\")";
		
		// If it is associated to their Wifi network
		if(associatedToWifiNetwork(_settings.getHomeWifiMAC()))
			return "Connected to your Wifi network";
		
		// If the device is wired to their home network
		if(wiredToNetwork(_settings.getHomeWifiMAC()))
			return "On your network via an Ethernet cable";
		
		if(getName().equals("Creative D200"))
			return "Wireless Peripheral (Audio/Video)";
		
		// Otherwise, return a manufacturer...
		return "Manufacturer: " + getManufacturer();		
	}
	
	/** This checks to see if the device is wired to the home network.  For this to be true, it
	 * must have an IP address belonging to the network and it must not be associated to the Wifi network.
	 * @return true if wired to the home network, false otherwise.
	 */
	public boolean wiredToNetwork(String homeWifiNetworkMAC) {
		for(Interface iface : _interfaces)
			if(iface.hasValidIP() && !associatedToWifiNetwork(homeWifiNetworkMAC))
				return true;
		return false;
	}
	
	/** Checks to see if the device has a wireless interface and is associated to the
	 * home Wifi network.
	 * @return true if associated to the Wifi network, false otherwise.
	 */
	public boolean associatedToWifiNetwork(String networkMAC) {
		for(Interface iface : _interfaces)
			if(iface.getClass()==WirelessInterface.class 
				&& ((WirelessInterface)iface)._BSSID!=null && ((WirelessInterface)iface)._BSSID.equals(networkMAC))
				return true;
		
		// Else, if one of the wireless interfaces has a valid IP
		for(Interface iface : _interfaces)
			if(iface.getClass()==WirelessInterface.class && iface.hasValidIP())
				return true;
		
		return false;
	}
	
	/** Checks to see if this device has the wired gateway interface (e.g., 192.168.1.1)
	 * @return true if it has the gateway interface, false otherwise.
	 */
	public boolean hasGatewayInterface() {
		for(Interface iface : _interfaces)
			if(iface.getClass()==WiredInterface.class && ((WiredInterface)iface)._gateway)
				return true;
		return false;
	}
	
	/** Checks if this device has an interface that matches a specific MAC
	 * @param MAC the MAC to check for
	 * @return true if this device has an interface with 'MAC', false otherwise.
	 */
	public boolean hasInterfaceWithMAC(String MAC) {
		for(Interface iface : _interfaces)
			if(iface._MAC!=null && iface._MAC.equals(MAC))
				return true;
		return false;
	}
	
	public String toFormattedString() {
		String result = "<b>Device: " + getName() + "<b>\n";
		List<Interface> interfaces = getInterfaces();
		for(Interface iface : interfaces)
			result += " ... " + iface.toString() + "\n";
		return result;
	}
	
	@Override
	public String toString() {
		return toFormattedString().toString();
	}
	
	/**
	 * Checks if the device has a Wifi interface
	 * @return true if the device has Wifi interface, false otherwise.
	 */
	public boolean hasWifiInterface() {
		for(Interface iface : _interfaces)
			if(iface._type==Wifi.class)
				return true;
		return false;
	}
	
	/** 
	 * Get the IP address of any of the interfaces that aren't null.
	 * @return the IP of the first active interface with an IP.
	 */
	public String getIP() {
		for(Interface iface : _interfaces)
			if(iface.hasValidIP())
				return iface._IP;
		return null;
	}
	
	/**
	 * Returns the device's unique key that was randomly generated.
	 * @return the device key.
	 */
	public int getKey() { return _deviceKey; }
	
	/** Be careful, this should only be used by the database.  Otherwise, keys
	 * are randomly generated and properly passed around.
	 * @param value the value to set
	 */
	public void setKey(int value) { _deviceKey=value; }
	
	/**
	 * Attempts to get the manufacturer of the device by getting the OUI name
	 * of any one of its interfaces.
	 * @return returns the manufacturer name.
	 */
	public String getManufacturer() {
		Collections.sort(_interfaces, Interface.byNameRank);
		// If we are still in this function, there were no interface names.  Return an OUI name.
		for(Interface iface : _interfaces)
			if(iface._ouiName != null)
				return iface.cleanOUIname();
		return "";
	}
	
	/** 
	 * This goes through the list of interfaces and returns true if one of the interfaces
	 * is on the home LAN.
	 * @return true if on the LAN, false otherwise.
	 */
	public boolean onHomeLAN() {
		for(Interface iface : _interfaces)
			if(iface.interfaceOnHomeLAN())
				return true;
		return false;
	}
	
	/** Returns the name for the device that was specified by the user, if there was one.
	 * @return the user's specified name
	 */
	public String getUserName() {
		return _userName;
	}
	
	/** Stores the user specified name for the device.
	 * @param name the name to be stored
	 */
	public void setUserName(String name) {
		_userName = name;
	}
	
	/** 
	 * This functionality could change in the future, but right now it returns
	 * _name if it is not null (could be chosen by the user).  Otherwise, it goes
	 * through the interfaces and returns the name of one of them. 
	 * 
	 * @return a human readable name for the device, null if for some reason there is no
	 * saved name
	 */
	public String getName() {
		if(_userName!=null)
			return _userName;
		
		Collections.sort(_interfaces, Interface.byNameRank);
		
		for(Interface iface : _interfaces) {
			
			if(iface._ifaceName != null) {
                
		          if(iface._ifaceName.matches("^android-.*") && iface.cleanOUIname()!=null)  // Do some magic for Android
		        	  return iface.cleanOUIname().split(" ")[0] + " Android Device";
		        	  
				return iface._ifaceName;
			}
			
		}
		
		// If we are still in this function, there were no interface names.  Return an OUI name.
		for(Interface iface : _interfaces)
			if(iface._ouiName != null)
				return iface.cleanOUIname();
		
		// Still here, means no OUI name either
		for(Interface iface : _interfaces)
			if(iface._MAC != null)
				return iface._MAC;		
		
		return "";
	}
	
	/** 
	 * Get the list of interfaces that are associated with the device.
	 * 
	 * @return a list of interfaces
	 */
	public List<Interface> getInterfaces() {
		return _interfaces;
	}
	
	/** Adds whatever interfaces it can from the given list to the device.
	 * @param interfaces the interfaces to add
	 */
	public void addInterfaces(ArrayList<Interface> interfaces) {
		for(Interface i : interfaces)
			addInterface(i);
	}
	
	/** 
	 * Tries to add the specified interface to this device.  This will
	 * fail if the interface already belongs.  This is checked by MAC address.
	 * @param iface the interface to add
	 * @return true if
	 */
	public boolean addInterface(Interface iface) {
		
		for(Interface i : _interfaces)
			if(iface._MAC.equals(i._MAC))
				return false;
		
		_interfaces.add(iface);
		
		return true;
	}
	
	/** This method generates a random long value which can be used for Interface
	 * keys to track them as they get "copied" but we need unique values for them
	 * that are persistent.
	 * @return returns a random int for use as a key
	 */
	public static int generateKey() {
		Random r = new Random();
		return r.nextInt();
	}
	
	// ********************************************************************* //
	// This code is to make this class parcelable and needs to be updated if
	// any new members are added to the Device class
	// ********************************************************************* //
    public int describeContents() {
        return this.hashCode();
    }

    public void writeToParcel(Parcel dest, int parcelableFlags) {
    	dest.writeList(_interfaces);
    	dest.writeString(_userName);
    	dest.writeInt(_mobile.ordinal());
    	dest.writeInt(_deviceKey);
    	dest.writeInt((_internal) ? 1 : 0);
    }

    public static final Parcelable.Creator<Device> CREATOR = new Parcelable.Creator<Device>() {
    	public Device createFromParcel(Parcel in) {
    		return new Device(in);
    	}

		public Device[] newArray(int size) {
			return new Device[size];
		}
    };

    private Device(Parcel source) {
    	_interfaces = new ArrayList<Interface>();
    	source.readList(_interfaces, this.getClass().getClassLoader());
    	_userName = source.readString();
    	_mobile = Device.Mobility.values()[source.readInt()];
    	_deviceKey = source.readInt();
    	_internal = (source.readInt()==1) ? true : false;
    }

}
